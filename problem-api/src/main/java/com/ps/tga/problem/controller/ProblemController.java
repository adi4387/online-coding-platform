package com.ps.tga.problem.controller;

import com.ps.tga.logger.LogEvent;
import com.ps.tga.problem.exception.ErrorResponse;
import com.ps.tga.problem.models.Problem;
import com.ps.tga.problem.models.ProblemResponse;
import com.ps.tga.problem.models.Topic;
import com.ps.tga.problem.service.ProblemService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.headers.Header;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.net.URI;
import java.util.UUID;

import static com.ps.tga.logger.Trace.TRACE_ID_KEY;
import static com.ps.tga.problem.constant.Constants.*;
import static com.ps.tga.problem.constant.Constants.RequestStatus.*;
import static io.swagger.v3.oas.annotations.enums.ParameterIn.HEADER;
import static io.swagger.v3.oas.annotations.enums.ParameterIn.QUERY;
import static org.springframework.http.ResponseEntity.created;
import static org.springframework.http.ResponseEntity.ok;

/**
 * The problem controller class to create and fetch problems
 *
 * @author adisingh16
 */
@RestController
@RequestMapping(PROBLEMS)
@RequiredArgsConstructor
@Slf4j
public class ProblemController {

    private final ProblemService problemService;

    @Operation(summary = "Onboard a device",
            parameters = {
                    @Parameter(name = TRACE_ID_KEY,
                            description = "Trace Id is used to promote visibility of processing that occurs within Apps and APIs as a result of message exchanges between them. It is intended that the TraceId will be stored in traces and support logs generated by the APIs which will be used in turn to identify and trace related activities.",
                            schema = @Schema(implementation = UUID.class),
                            example = "d84831f1-79ae-42c8-9dc4-d871c493ba75",
                            in = HEADER
                    )
            })
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Problem creation request",
                    headers = {
                            @Header(name = "content-type", schema = @Schema(implementation = String.class, defaultValue = "application/json")),
                            @Header(name = "location", schema = @Schema(implementation = String.class))
                    },
                    content = {@Content(mediaType = "application/json",
                            schema = @Schema(implementation = Problem.class))}),
            @ApiResponse(responseCode = "500", description = "Internal Server Error",
                    content = {@Content(mediaType = "application/json",
                            schema = @Schema(implementation = ErrorResponse.class, example = "{ \n code:500,\n message:error occurs \n}"))}),
            @ApiResponse(responseCode = "400", description = "Bad Request",
                    content = {@Content(mediaType = "application/json",
                            schema = @Schema(implementation = ErrorResponse.class, example = "{ \n code:400,\n message:Device Exists \n}")
                    )}
            )
    })
    @PostMapping
    public Mono<ResponseEntity<Void>> createProblem(@Valid @RequestBody Problem problem,
                                                    @RequestHeader(name = TRACE_ID_KEY, required = false) String traceId) {
        return Mono.just(problem)
                .doOnNext(p -> log.info(LogEvent.eventType(CREATE_PROBLEM).with("id", p.getId()).with(STATUS, PENDING).with(TRACE_ID_KEY, traceId).asJSON()))
                .flatMap(problemService::createProblem)
                .doOnSuccess(p -> log.info(LogEvent.eventType(CREATE_PROBLEM).with("id", p.getId()).with(STATUS, SUCCESS).with(TRACE_ID_KEY, traceId).asJSON()))
                .doOnError(throwable -> log.error(LogEvent.eventType(CREATE_PROBLEM).with("id", problem.getId()).with(STATUS, FAILURE).with(TRACE_ID_KEY, traceId).asJSON()))
                .map(problemMono -> created(URI.create(PROBLEMS + "/" + problemMono.getId())).build());
    }

    @Operation(
            summary = "Api to get all problems",
            parameters = {
                    @Parameter(name = LIMIT,
                            description = "Limit number of devices",
                            schema = @Schema(implementation = Integer.class),
                            example = "100",
                            in = QUERY
                    ),
                    @Parameter(name = OFFSET,
                            description = "Offset to fetch next page",
                            schema = @Schema(implementation = Integer.class),
                            example = "0",
                            in = QUERY
                    ),
                    @Parameter(name = TRACE_ID_KEY,
                            description = "Trace Id is used to promote visibility of processing that occurs within Apps and APIs as a result of message exchanges between them. It is intended that the TraceId will be stored in traces and support logs generated by the APIs which will be used in turn to identify and trace related activities.",
                            schema = @Schema(implementation = UUID.class),
                            example = "d84831f1-79ae-42c8-9dc4-d871c493ba75",
                            in = HEADER
                    )
            }
    )
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "get all problems with pagination",
                    headers = {
                            @Header(name = "content-type", schema = @Schema(implementation = String.class, defaultValue = "application/json"))
                    },
                    content = {@Content(mediaType = "application/json",
                            schema = @Schema(implementation = ProblemResponse.class))}),
            @ApiResponse(responseCode = "500", description = "Internal Server Error",
                    content = {@Content(mediaType = "application/json",
                            schema = @Schema(implementation = ErrorResponse.class, example = "{ \n code:500,\n message:error occurs \n}"))})
    })
    @GetMapping
    public Mono<ResponseEntity<ProblemResponse>> findAllProblems(@RequestParam(name = LIMIT, required = false, defaultValue = "10") Integer limit,
                                                                 @RequestParam(name = OFFSET, required = false, defaultValue = "0") Integer offset,
                                                                 @RequestHeader(name = TRACE_ID_KEY, required = false) String traceId) {
        return Flux.just("")
                .doOnNext(p -> log.info(LogEvent.eventType(GET_PROBLEMS).with(STATUS, PENDING).with(TRACE_ID_KEY, traceId).asJSON()))
                .flatMap(p -> problemService.findAllProblems(limit, offset))
                .collectList()
                .doOnSuccess(p -> log.info(LogEvent.eventType(GET_PROBLEMS).with(STATUS, SUCCESS).with(TRACE_ID_KEY, traceId).asJSON()))
                .doOnError(throwable -> log.error(LogEvent.eventType(GET_PROBLEMS).with(STATUS, FAILURE).with(TRACE_ID_KEY, traceId).asJSON()))
                .map(problems -> ok(new ProblemResponse(problems)));
    }

    @Operation(
            summary = "Api to get all problems by topic",
            parameters = {
                    @Parameter(name = TOPIC,
                            description = "Topic of the problem",
                            schema = @Schema(implementation = Integer.class),
                            example = "100",
                            in = QUERY
                    ),
                    @Parameter(name = LIMIT,
                            description = "Limit number of devices",
                            schema = @Schema(implementation = Integer.class),
                            example = "100",
                            in = QUERY
                    ),
                    @Parameter(name = OFFSET,
                            description = "Offset to fetch next page",
                            schema = @Schema(implementation = Integer.class),
                            example = "0",
                            in = QUERY
                    ),
                    @Parameter(name = TRACE_ID_KEY,
                            description = "Trace Id is used to promote visibility of processing that occurs within Apps and APIs as a result of message exchanges between them. It is intended that the TraceId will be stored in traces and support logs generated by the APIs which will be used in turn to identify and trace related activities.",
                            schema = @Schema(implementation = UUID.class),
                            example = "d84831f1-79ae-42c8-9dc4-d871c493ba75",
                            in = HEADER
                    )
            }
    )
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "get all problems with pagination",
                    headers = {
                            @Header(name = "content-type", schema = @Schema(implementation = String.class, defaultValue = "application/json"))
                    },
                    content = {@Content(mediaType = "application/json",
                            schema = @Schema(implementation = ProblemResponse.class))}),
            @ApiResponse(responseCode = "500", description = "Internal Server Error",
                    content = {@Content(mediaType = "application/json",
                            schema = @Schema(implementation = ErrorResponse.class, example = "{ \n code:500,\n message:error occurs \n}"))})
    })
    @GetMapping("/topic/{topic}")
    public Mono<ResponseEntity<ProblemResponse>> findAllProblemsByTopic(
            @PathVariable(name = "topic") Topic topic,
            @RequestParam(name = "limit", required = false, defaultValue = "10") Integer limit,
            @RequestParam(name = "offset", required = false, defaultValue = "0") Integer offset,
            @RequestHeader(name = "traceId", required = false) String traceId) {
        return Flux.just("")
                .doOnNext(p -> log.info(LogEvent.eventType(GET_PROBLEMS_BY_TOPIC).with(STATUS, PENDING).with(TRACE_ID_KEY, traceId).asJSON()))
                .flatMap(p -> problemService.findAllProblemsByTopic(topic, limit, offset))
                .collectList()
                .doOnSuccess(p -> log.info(LogEvent.eventType(GET_PROBLEMS_BY_TOPIC).with(STATUS, SUCCESS).with(TRACE_ID_KEY, traceId).asJSON()))
                .doOnError(throwable -> log.error(LogEvent.eventType(GET_PROBLEMS_BY_TOPIC).with(STATUS, FAILURE).with(TRACE_ID_KEY, traceId).asJSON()))
                .map(problems -> ok(new ProblemResponse(problems)));
    }

    @Operation(
            summary = "Api to get all problems",
            parameters = {
                    @Parameter(name = LIMIT,
                            description = "Limit number of devices",
                            schema = @Schema(implementation = Integer.class),
                            example = "100",
                            in = QUERY
                    ),
                    @Parameter(name = OFFSET,
                            description = "Offset to fetch next page",
                            schema = @Schema(implementation = Integer.class),
                            example = "0",
                            in = QUERY
                    ),
                    @Parameter(name = TRACE_ID_KEY,
                            description = "Trace Id is used to promote visibility of processing that occurs within Apps and APIs as a result of message exchanges between them. It is intended that the TraceId will be stored in traces and support logs generated by the APIs which will be used in turn to identify and trace related activities.",
                            schema = @Schema(implementation = UUID.class),
                            example = "d84831f1-79ae-42c8-9dc4-d871c493ba75",
                            in = HEADER
                    )
            }
    )
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "get all problems with pagination",
                    headers = {
                            @Header(name = "content-type", schema = @Schema(implementation = String.class, defaultValue = "application/json"))
                    },
                    content = {@Content(mediaType = "application/json",
                            schema = @Schema(implementation = ProblemResponse.class))}),
            @ApiResponse(responseCode = "500", description = "Internal Server Error",
                    content = {@Content(mediaType = "application/json",
                            schema = @Schema(implementation = ErrorResponse.class, example = "{ \n code:500,\n message:error occurs \n}"))})
    })
    @GetMapping("/{id}")
    public Mono<ResponseEntity<Problem>> findByID(@PathVariable String id,
                                                  @RequestHeader(name = "traceId", required = false) String traceId) {
        return Mono.just(id)
                .doOnNext(p -> log.info(LogEvent.eventType(GET_PROBLEM_BY_ID).with(STATUS, PENDING).with(TRACE_ID_KEY, traceId).asJSON()))
                .flatMap(p -> problemService.findById(id))
                .doOnSuccess(p -> log.info(LogEvent.eventType(GET_PROBLEM_BY_ID).with(STATUS, SUCCESS).with(TRACE_ID_KEY, traceId).asJSON()))
                .doOnError(throwable -> log.error(LogEvent.eventType(GET_PROBLEM_BY_ID).with(STATUS, FAILURE).with(TRACE_ID_KEY, traceId).asJSON()))
                .map(ResponseEntity::ok);
    }
}
